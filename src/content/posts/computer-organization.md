---
title: 计算机组成原理与系统结构考纲
slug: computer-organization
date: 2020-01-08 15:46:43
thumbnail: /images/cover/e4a4c118c3d5961a8f246ce6f9e5be7f.png
categories:
  - Coding
tags:
  - 计算机组成原理
  - 学习
---

## 题型

选择题（20 分）

填空题（10 分）

判断题（10 分）

简答题（20 分）

名词解释（10 分）

分析计算题（30 分）

## 第一章 计算机组成原理概论

### 冯诺伊曼思想

核心：存储程序控制

采用二进制表示数据和指令：指令由操作码和地址码组成。

计算机由五大部件组成，并规定了五大部件的基本功能。

#### 五大部件

1. 存储器
   功能：存放指令和数据。
   操作：

   - 存储器读操作：从存储器取出数据，又称为读出。
   - 存储器写操作：向存储器存放数据，又称为写入；
     概念：
   - 存储单元：存储二进制信息的部件，每个单元可以存放一个字或字节的信息，存储器就是存储单元的集合。
   - 单元地址：存储单元的编号，是区分存储器中不同存储单元的唯一标志。

2. 运算器
   功能：在控制器控制下，进行算术运算和逻辑运算。
   运算器的技术性能高低直接影响着计算机的运算速度和整机性能。

3. 控制器
   功能：对当前指令进行译码分析其所需要完成的操作，产生并发送各部件所需要的控制信号，从而使整个计算机自动、协调地工作。（即：执行程序，控制全机各部件协调运转。）
   控制器是计算机的控制指挥部件，也是整个计算机的控制中心。

4. 输入设备
   功能：将外界的信息转换为计算机能识别的二进制代码。输入设备是给计算机输入信息的设备。

5. 输出设备
   功能：将计算机处理结果转换成人们或其他设备所能接收的形式。

### 计算机层次结构

微程序设计级（第一层）：这是计算机的最底层硬件，使用微程序或硬布线来实现机器指令的功能。

机器指令系统级（第二层）：它所提供的是那些计算机硬件能读懂的，兵可以直接操控计算机硬件工作的二进制信息，即机器指令。它是软硬件的分界面：硬件设计者一句他来设计硬件，软件设计者是用它来控制计算机硬件工作。

操作系统级（第三层）：它由操作系统程序实现，用于管理、统一调度硬件资源、支撑其他系统软件和应用软件，使计算机能够自动运行，发挥高效率的作用。

语言处理程序及其他系统软件级（第四层）：语言处理程序功能是将程序员编写的高级语言源程序翻译成机器语言程序。

面向用户应用程序级（第五层）：它是针对计算机用户在某一应用领域、某些专门问题而设计开发的应用程序。

<img src="/images/computer-organization.assets/image-20191221144843057.png" alt="image-20191221144843057" style="zoom:150%;" />

### 性能指标

#### 机器字长

概念：是指 CPU 一次能处理的数据位数，它决定了寄存器、运算部件、数据总线的位数。

作用：影响计算机的性能，指令系统的功能。机器字长越长，数的表示范围也越大，精度也越高，但其相应的硬件成本也越高。指令长度受限于机器字长。

#### 存储容量

概念：存储器能存储的最大二进制信息量，一般以位（bits）或者字节（1Bytes = 8bits）为单位。

组成：

- 主存储器容量
- 辅助存储器容量

主存储器：CPU 能通过地址线直接访问的存储器，如 RAM、ROM 等，用于存放 CPU 正在执行或要执行的程序和数据。

辅助存储器：主存储器以外的存储器，如硬盘、U 盘等，用于存放备用的程序和数据。

#### 运算速度

用 **MIPS**(Million Instructions Per seconds，每百万条指令每秒)表示。

## 第三章 信息编码与数据表示

### 数值转换

十进制（Decimal）、二进制（Binary）、八进制（Octal）、十六进制（Hexdecimal）数分别用 D、B、Q、H 来标志。

#### 常用的几种数制的对应关系

| **十进制** | **二进制** | **八进制** | **十六进制** | **十进制** | **二进制** | **八进制** | **十六** **进制** |
| ---------- | ---------- | ---------- | ------------ | ---------- | ---------- | ---------- | ----------------- |
| **0**      | **0000**   | **0**      | **0**        | **8**      | **1000**   | **10**     | **8**             |
| **1**      | **0001**   | **1**      | **1**        | **9**      | **1001**   | **11**     | **9**             |
| **2**      | **0010**   | **2**      | **2**        | **10**     | **1010**   | **12**     | **A**             |
| **3**      | **0011**   | **3**      | **3**        | **11**     | **1011**   | **13**     | **B**             |
| **4**      | **0100**   | **4**      | **4**        | **12**     | **1100**   | **14**     | **C**             |
| **5**      | **0101**   | **5**      | **5**        | **13**     | **1101**   | **15**     | **D**             |
| **6**      | **0110**   | **6**      | **6**        | **14**     | **1110**   | **16**     | **E**             |
| **7**      | **0111**   | **7**      | **7**        | **15**     | **1111**   | **17**     | **F**             |
|            |            |            |              | **16**     | **10000**  | **20**     | **10**            |

#### 二、八、十六进制转换为十进制

转换方法：加权求和。(按式 4－1)
例：\((5AC.E6)16= 5\times16^{2}＋ 10\times16^{1} ＋12\times16^{0} ＋14\times16^{－1}＋ 6\times16^{－2} ＝(1452.8984375)_{10}\)

例如：
\((1011)_{2} → (1011)_B → 1011B → 1011b\)
\((123.45)_2 → ( 123.45 )_D → 123.45D → 123.45\)
\((2B.D)_16 = (2B.D)_H = (43.8125)_10 = (53.64)_Q\)

#### 十进制转换为二、八、十六进制

转换方法：可以分为以下两种方法
直接转换：十进制 → 二、八、十六进制
间接转换：十进制 → 二进制 → 八、十六进制

#### 十进制转化为 R 进制

转换方法
整数部分：除以 R 取余，先得低位，直到商为 0。
小数部分：乘 R 取整，先得高位，直到积为 0 或者达到精度要求为止。BCD 码（8421 码）

### 几种常见的 BCD 码

8421 码：
特点：4 位二进制数位的权从高到低依次是 8、4、2、1；8421 码实际上就是十进制数字 0 ～ 9 的二进制编码本身。
是最常用的一种 BCD 码，在没有特别指出的一般情况下，所提到的 BCD 码通常就是指 8421 码。
格雷码：
特点：又叫循环码，它的任何相邻的两个编码（例如 2 和 3、7 和 8、9 和 0 等）之间只有一位二进制位不同。
优点：是用它构成计数器时，在从一个编码变到下一个编码时，只有一个触发器翻转即可，波形更完美、可靠。
格雷码的编码方案有许多种。
余 3 码：对应的 8421 码加上 0011 构成的

| **十进制数** | **8421 码** | **2421 码** | **5211 码** | **4311 码** | **84-2-1 码** | **格雷码** | **余 3 码** |
| ------------ | ----------- | ----------- | ----------- | ----------- | ------------- | ---------- | ----------- |
| **0**        | **0000**    | **0000**    | **0000**    | **0000**    | **0000**      | **0000**   | **0011**    |
| **1**        | **0001**    | **0001**    | **0001**    | **0001**    | **0111**      | **0001**   | **0100**    |
| **2**        | **0010**    | **0010**    | **0011**    | **0011**    | **0110**      | **0011**   | **0101**    |
| **3**        | **0011**    | **0011**    | **0101**    | **0100**    | **0101**      | **0010**   | **0110**    |
| **4**        | **0100**    | **0100**    | **0111**    | **1000**    | **0100**      | **0110**   | **0111**    |
| **5**        | **0101**    | **1011**    | **1000**    | **0111**    | **1011**      | **1110**   | **1000**    |
| **6**        | **0110**    | **1100**    | **1010**    | **1011**    | **1010**      | **1010**   | **1001**    |
| **7**        | **0111**    | **1101**    | **1100**    | **1100**    | **1001**      | **1000**   | **1010**    |
| **8**        | **1000**    | **1110**    | **1110**    | **1110**    | **1000**      | **1100**   | **1011**    |
| **9**        | **1001**    | **1111**    | **1111**    | **1111**    | **1111**      | **0100**   | **1100**    |

### 定点数

#### 原码表示法

##### 表示方法

最高位表示数的符号，其他位表示数值位。
符号位：0－正数，1－负数。
数值位：与绝对值相同。

对于定点整数：
若\(X=+X_1X_2 \dots\dots X_n\)，则 \([X]_原= 0,X_1X_2 \dots\dots X_n\)
若\(X=- X_1X_2 \dots\dots X_n\)，则 \([X]_原= 1,X_1X_2 \dots\dots X_n\)
对于定点小数：
若\(X=+0. X_1X_2 \dots\dots X_n\)，则 \([X]_原= 0.X_1X_2 \dots\dots X_n\)
若\(X=- 0.X_1X_2 \dots\dots X_n\)，则 \([X]_原= 1.X_1X_2 \dots\dots X_n\)

> `,` 和 `.` 只用于助记，在计算机中并无专用部件来表示

##### 0 的表示

0 的原码表示有两种形式，即分别按照正数和负数表示。

\([+0]_原＝ 00…0\) \([-0]_原＝ 10…0\)

##### 表示范围

对于 n ＋ 1 位原码机器数 X，它所能表示的数据范围为：
定点整数：\(-(2^n-1) \leq X \leq 2^n－1\)
定点小数：\((1-2^{-n}) \leq X \leq 1-2^{-n}\)

#### 补码表示法

##### 表示方法

最高位为符号位，其他位为数值位。
符号位：0－正数，1－负数。
数值位：正数时，与绝对值相同；**负数时，为绝对值取反后，末位加 1**

对于定点整数：
若\(X=+X_1X_2 \dots\dots X_n\)，则 \([X]_补= 0,X_1X_2 \dots\dots X_n\)
若\(X=- X_1X_2 \dots\dots X_n\)，则 \([X]_补= 1,\overline{X_1X_2 \dots\dots X_n} + 1\)
对于定点小数：
若\(X=+0. X_1X_2 \dots\dots X_n\)，则 \([X]_补= 0.X_1X_2 \dots\dots X_n\)
若\(X=- 0.X_1X_2 \dots\dots X_n\)，则 \([X]_补= 1.\overline{X_1X_2 \dots\dots X_n} + 0.00\dots\dots1 \)

##### 0 的表示

0 的原码表示有两种形式，即分别按照正数和负数表示。

\([+0]_补＝ 00…0\) \([-0]_补＝ 00…0\)

##### 表示范围

对于 n ＋ 1 位原码机器数 X，它所能表示的数据范围为：
定点整数：\(-2^n \leq X \leq 2^n－1\)
定点小数：\(-1 \leq X \leq 1-2^{-n}\)

> 计算机中的整型数据（int）均用补码来表示。包括 1 位符号位，n 位数值位

#### 反码表示法

##### 表示方法

最高位为符号位，其他位为数值位。
符号位：0－正数，1－负数。
数值位：正数时，与绝对值相同；**负数时，为绝对值取反**

对于定点整数：
若\(X=+X_1X_2 \dots\dots X_n\)，则 \([X]_反= 0,X_1X_2 \dots\dots X_n\)
若\(X=- X_1X_2 \dots\dots X_n\)，则 \([X]_反= 1,\overline{X_1X_2 \dots\dots X_n}\)
对于定点小数：
若\(X=+0. X_1X_2 \dots\dots X_n\)，则 \([X]_反= 0.X_1X_2 \dots\dots X_n\)
若\(X=- 0.X_1X_2 \dots\dots X_n\)，则 \([X]_反= 1\overline{X_1X_2 \dots\dots X_n}\)

##### 0 的表示

0 的原码表示有两种形式，即分别按照正数和负数表示。

\([+0]_反＝ 00…0\) \([-0]_反＝ 11…1\)

##### 表示范围

对于 n ＋ 1 位原码机器数 X，它所能表示的数据范围为：
定点整数：\(-(2^n-1) \leq X \leq 2^n－1\)
定点小数：\(-(1-2^{-n}) \leq X \leq 1-2^{-n}\)

> 包括 1 位符号位，n 位数值位

#### 移码表示法

##### 表示方法

最高位为符号位，其他位为数值位。
符号位：1－正数，0－负数。
数值位：正数时，与绝对值相同；**负数时，为绝对值取反后，末位加 1**。

对于定点整数：
若\(X=+X_1X_2 \dots\dots X_n\)，则 \([X]_移= 1,X_1X_2 \dots\dots X_n\)
若\(X=- X_1X_2 \dots\dots X_n\)，则 \([X]_移= 0,\overline{X_1X_2 \dots\dots X_n} + 1\)
对于定点小数：
若\(X=+0. X_1X_2 \dots\dots X_n\)，则 \([X]_移= 1.X_1X_2 \dots\dots X_n\)
若\(X=- 0.X_1X_2 \dots\dots X_n\)，则 \([X]_移= 0.\overline{X_1X_2 \dots\dots X_n} + 0.00 \dots\dots 1\)

> 移码表示：即为补码的符号位取反

##### 0 的表示

0 的原码表示有两种形式，即分别按照正数和负数表示。

\([+0]_移＝ 10…0\) \([-0]_移＝ 10…0\)

##### 表示范围

对于 n ＋ 1 位原码机器数 X，它所能表示的数据范围为：
定点整数：\(-2^n-1 \leq X \leq 2^n－1\)
定点小数：\(-1 \leq X \leq 1-2^{-n}\)

> 包括 1 位符号位，n 位数值位
> 移码通常作为浮点数的阶码。

#### 定点机器数转换

##### 机器数转换为真值

四种定点机器数转换为真值的方法要点是：首先根据机器数的符号位确定真值的正负，然后对照机器数的定义和表示，反方向求出真值的绝对值

##### 机器数之间的相互转换

原码、补码、反码和移码之间的相互转换，最简单的方法是先求出它们的真值，然后再转换为另一种表示方法。

### 浮点数

#### 浮点机器数的格式

浮点机器数用于表示实数，其小数点的位置由其中的阶码规定，因此是浮动的。
浮点数 N 的构成：\(N = M \times R^E\)
浮点数的格式：阶码的底是隐含规定的。

> 在机器中，为了方便浮点数大小的比较，通常将数符放置在浮点数的首位。

尾数 M：为定点小数，尾数的位数决定了浮点数有效数值的精度，尾数的符号代表了浮点数的正负，因此又称为数符。尾数一般采用原码和补码表示。

阶码 E：为定点整数，阶码的数值大小决定了该浮点数实际小数点位置与尾数的小数点位置（隐含）之间的偏移量。阶码的位数多少决定了浮点数的表示范围。阶码的符号叫阶符。阶码一般采用移码和补码表示。

阶码的底 R：一般为 2、8 或 16 ，且隐含规定。

<img src="/images/computer-organization.assets/image-20191225230227933.png" alt="image-20191225230227933" style="zoom:150%;" />

**短实数**又称为**单精度浮点数**，**长实数**又称为**双精度浮点数**，**临时实数**主要用于进行浮点数运算时保存临时的计算结果。

#### IEEE 754 国际标准

根据 IEEE 754 国际标准，常用的浮点数格式有 3 种，阶码的底隐含为 2。

**尾数** 用 **原码** 表示、**阶码** 用 **移码** 表示，偏置量为 127 或 1023，阶码至少为 1，所以偏置 127 ，127+1=128 它是规格化浮点数。

隐含最高有效位 1，即这位并不出现在浮点数的代码序列中，因此尾数实际上相当于 24 位。所以相应地尾数的真值等于 1（整数部分）+M（小数部分，23 位）得到真值 \( (-1)^{Ms} \times (1.M_1M_2M_3…M_{23}) \times 2^{E-127} \) —— 32 位表示法

<img src="/images/computer-organization.assets/image-20191225230616259.png" alt="image-20191225230616259" style="zoom:150%;" />

例题：将十进制数 20.59375 转换成 IEEE754 的 32 位标准浮点数的二进制格式来存储，并写出其 16 进制数。

解答：首先分别将整数和分数部分转换成二进制数：
\(20.59375 ＝ 10100.10011\)
然后移动小数点，使其在第 1、2 位之间
\( 10100.10011 ＝ 1.010010011 \times 2^4 \)
小数点被左移了 4 位，于是得到：e ＝ 4
尾符 \(M_s＝0\)，阶码 \(E＝4＋127＝131\)，
尾数 \(M＝010010011\)
最后得到 32 位浮点数的二进制存储格式为：
\(\underbrace{0}_{符号位} \quad \underbrace{10000011}_{阶码} \quad \underbrace{010 \quad 0100 \quad 1100 \quad 0000 \quad 0000 \quad 0000}_{尾数} ＝ (41A4C000)_{16}\)

#### 规格化

给真值，求浮点数表示

##### 尾数

- 原码表示：最高有效位(\(M_1\))为 1 时，浮点数为规格化，即尾数为 \(X.1X \cdots\)
- 补码表示：符号位(\(M_s\))与最高有效位(\(M_1\))相异时，浮点数为规格化表示，即尾数为 \(0.1X \cdots X\) 或者 \(1.0X \cdots X\)

#### 溢出

一道选择题，阶码溢出，取决于**阶码上溢**

### 机器数

### 校验码

​ 奇偶校验码——选择题，数一的个数
​ CRC 校验码——根据多项式，模二除（异或运算）
​ 海明校验码——不考

### ASCII 码

## 第四章 运算方法与运算器

### 定点数的加减运算

补码加减器实现

#### 补码加减运算方法

补码的加减运算的公式是：
\([X+Y]_补 = [X]_补 + [Y]_补\)
\([X-Y]_补 = [X]_补 + [-Y]_补\)
特点：
使用补码进行加减运算，符号位和数值位一样参加运算。
补码的减法可以用加法来实现，任意两数之差的补码等于被减数的补码与减数相反数的补码之和。

##### 求补运算：[Y]补 → [-Y]补

[-Y]补求补规则：将[Y]补包括符号位在内每一位取反，末位加 1。
若\([Y]_补 = Y_0，Y_1……Y_n\) ，则：\([-Y]_补 = \overline{Y_0Y_1 \dots Y_n} + 1\)

若\([Y]_补 = Y_0.Y_1……Y_n\) ，则：\([-Y]_补 = \overline{Y_0Y_1 \dots Y_n} + 0.0 \dots 1\)

例

\([X]_补  = 0.1101\) 则：\([-X]_补  = 1.0011\)

\([X]_补  = 1.1101\) 则：\([-X]_补  = 0.0011\)

### **溢出判断**

#### 进位

#### 单符号位

#### 双符号位（变形补码）

00 为正数。

11 为负数。

01 为正溢出

10 为负溢出。

### 移位运算——选择题

二进制数据（真值）每相对于小数点左移一位，相当于乘以 2；每相对于小数点右移一位，相当于除以 2。

#### 逻辑移位

无符号数据，对无符号数据的数值放大或缩小。

左移：高位移出，低位补 0

右移：低位移出，高位补 0

#### 算术移位

带符号数据，符号位不变，在数值的绝对值上放大或缩小。

左移：符号位不变，高位移出，低位补 0，左移出的数据位为 1 时，溢出。

右移：符号位不变，低位移出，高位补 0

## 第五章 存储体系 （15 分～ 20 分）

### 主存储器（内存）

一般由 RAM 和 ROM 组成。

#### SRAM 和 DRAM 的不同：

|        比较内容        |     SRAM     |       DRAM       |
| :--------------------: | :----------: | :--------------: |
| 存储信息 0 和 1 的方式 | 双稳态触发器 | 极间电容上的电荷 |
|      电源不掉电时      |   信息稳定   |    信息会丢失    |
|          刷新          |    不需要    |       需要       |
|         集成度         |      低      |        高        |
|          容量          |      小      |        大        |
|          价格          |      高      |        低        |
|          速度          |      快      |        慢        |
|        适用场合        |    Cache     |       主存       |

#### DRAM

DRAM 的地址一般分两次接收，因为 DRAM 一般容量较大，为减少地址译码输出线，采用双向译码；并且为节省外引线，减低成本，DRAM 芯片地址线根数减少一半，行列地址分时复用，所以需要分两次接收。

##### 刷新

例： 64K×1 位 DRAM 芯片中，存储电路由 4 个独立的 128×128 的存储矩阵组成。设存储器存储周期为 500ns ，单元刷新间隔是 2ms。

###### 集中式刷新

在 2ms 单元刷新间隔时间内，集中对 128 行刷新一遍，所需时间 \(128×500ns=64μs\)，其余时间则用于访问操作。
在内部刷新时间（64μs）内，不允许访存，这段时间被称为**死时间**。

###### 分散式刷新

在任何一个存储周期内，分为访存和刷新两个子周期。
访存时间内，供 CPU 和其他主设备访问。
在刷新时间内，对 DRAM 的某一行刷新。
存储周期为**存储器存储周期的两倍**，即 \(500ns \times 2＝1μs\)。
**刷新周期缩短**，为 \(128 \times 1μs ＝128μs\) 。在 2ms 的单元刷新间隔时间内，对 DRAM 刷新了 \(2ms ÷ 128μs\) 遍

###### 异步式刷新

异步刷新采取折中的办法，在 2ms 内分散地把各行刷新一遍。
避免了分散式刷新中不必要的多次刷新，提高了整机速度；同时又解决了集中式刷新中“死区”时间过长的问题。
刷新信号的周期为 \(2ms/128=15.625μs\)。让刷新电路每隔 \(15μs\) 产生一个刷新信号，刷新一行。

### 扩充——主存储器与 CPU 的链接

#### 位扩充

要求：用 1K×4 位 的 SRAM 芯片 → 1K×8 位的 SRAM 存储器

\(容量 = 2^{10} \times 8位\)

#### 字扩充

要求：用 1K×8 位 的 SRAM 芯片 → 2K×8 位的 SRAM 存储器

#### 字位扩充

需扩展的存储器容量为 M × N 位 , 已有芯片的容量为 L × K 位 (L<M, K<N)

计算：\( \frac{M \times N}{L \times K} \)

用 M/L 组 芯片进行字扩展;
每组内有 N/K 个 芯片进行位扩展。

> 分组：字长 / 字长
>
> 地址位：片内，片外

### Cache（判断题）

作用：用于弥补 CPU 和主存之间的速度差异，提高 CPU 访问主存的平均速度。

名词解释：指位于 CPU 和主存之间的一个**高速小容量的存储器**，一般由 SRAM 构成。

#### 命中率

命中率指 CPU 访问主存数据时，命中 Cache 的次数，占全部访问次数的比率；

失效率就指不命中 Cache 的次数，占全部访问次数的比率。

命中率 h 取决于程序的行为、Cache 的容量、组织方式、块大小。

在一个程序执行期间，设 \(N_c\) 表示 Cache 完成存取的总次数，\(N_m\) 表示主存完成存取的总次数，则命中率：\(h = \frac{N_c}{N_c + N_m}\)

若 \(t_c\) 表示 Cache 的访问时间，\(t_m\) 表示主存的访问时间，则 Cache/主存系统 的平均访问时间 ta 为：

\@@@
t_a = ht_c + (1 - h) \times (t_m + t_c) \\
t_a = ht_c + (1-h)t_m
\@@@

Cache/主存系统的访问效率 e：\(e = \frac{t_c}{t_a}\)

#### 写策略

##### 写贯穿策略

当 CPU 写 Cache 命中时，所有写操作既对 Cache 也对主存进行；当 CPU 写 Cache 不命中时，直接写主存，有两种做法：

1. 不将该数据所在的块拷贝到 Cache 行，称为 WTNWA 法；
2. 将该数据所在块拷贝到 Cache 的某行，称为 WTWA 法。

##### 写回策略

当 CPU 写 Cache 命中时，写操作只是对 Cache 进行，而不修改主存的相应内容，仅当此 Cache 行被换出时，相应的主存内容才被修改；当 CPU 写 Cache 不命中时，先将该数据所在块拷贝到 Cache 的某行，余下操作与 Cache 写命中时相同。

为了区别 Cache 行是否被改写过，应为每个 Cache 行设置一个**修改位**，CPU 修改 Cache 行时，标记其修改位，当此 Cache 行被换出时，判别此 Cache 行的修改位，从而决定是否将 Cache 行数据写回主存相应单元。

##### 两种写策略比较

写贯穿策略保证了主存数据总是有效，写回策略可能导致 Cache 和主存数据不一致；

写回策略的效率高于写贯穿策略；

写回策略的控制比写贯穿策略的控制复杂。

#### 映射(重点)

##### 直接映射

特点：是一种多对一的映射关系：主存的第 i 块一定映射到 Cache 的第 j 行，且：\( j = i \: mod \: 2^c\)

优点：映射方式简单，易实现。

缺点：机制不灵活，Cache 命中率低。

##### 全相联映射

特点：是多对多的映射关系：对于主存的任何一块均可以映射到 Cache 的任何一行。

优点：机制灵活，命中率高。

缺点：比较器电路难于设计和实现，因此只适合于小容量的 Cache。

##### 组相联映射

特点：将 Cache 的行分成 2c-r 组，每组 2r 行。主存的字块存放到 Cache 中的哪个组是固定的，至于映射到该组哪一行是灵活的，即有如下函数关系：\( j = (i \: mod \: 2^{c-r}) \times 2^r + k \quad （其中 0 \leq k \leq 2^{r-1}）\)

优点：大大增加了映射的灵活性，主存中一块可映射到 Cache 的 2r 块，提高了命中率。每次比较只是进行 r .2r 路比较，r 较小时，硬件开销不是很大。

组相联映像通常采用 2 路、4 路和 8 路比较，即取 r=1, r=2, r=3。

##### 主存地址

\(主存字块标记 \quad 组地址 \quad 块内地址\)

### 只读存储器

##### 掩模型只读存储器（MROM）

内容由生产过程中的一种掩模工艺决定的，一旦生产完毕，其内容不能改写。

特点：可靠性高、集成度高、价格便宜、使用与程序成熟、批量生产的场合。

##### 可编程只读存储器（PROM）

内容由用户在使用前一次性写入。

##### 可多次编程的只读存储器（ERROM 和 \(E^2PROM\)）

##### 闪速存储器

### 虚拟存储器（没考）

### 性能指标

#### 存储容量

指存储器可容纳的二进制信息量，描述存储容量的单位是字节或位。

量化单位：
1K ＝\(2^{10}\) 1M ＝\(2^{20}\) 1G ＝\(2^{30}\) 1T ＝\(2^{40}\)

​ \(存储容量 = 存储字数（存储单元数）\times 字长（每个单元的位数）\)

#### 速度

存取时间（Memory Access Time）：指启动一次存储器操作到完成该操作所需的全部时间。存取时间愈短，其性能愈好。通常存取时间用纳秒（\(ns ＝ 10^{-9}s\)）为单位。

存储周期（Memory Cycle Time）：指存储器进行连续两次独立的存储器操作所需的最小间隔时间。
通常存取周期 TC 大于存取时间 tA ，即 TC≥tA。

存储器带宽：是单位时间里存储器所能存取的最大信息量，存储器带宽的计量单位通常是位/秒（bps）或字节/秒，它是衡量数据传输速率的重要技术指标。

#### 价格

## 第六章 指令系统

指令包括：

- 操作码：用来指明该指令所要完成的操作，即定义指令的功能
- 地址码：用来寻找执行指令所需要的操作数，及操作数的地址信息。

### 名词解释

指令字：地标指令的一组二进制信息。

指令字长：一条指令中所包含的二进制码的位数。

机器字长：即计算机字长，指计算机能直接处理的二进制数据的位数，它决定了计算机运算的精度。

### 重点——选择题

#### 寻址方式

##### 指令寻址

###### 顺序寻址方式

控制器中**使用程序计数器 PC 来指示指令在内存中的地址**。在程序顺序执行时，指令的地址码由 PC 自加 1 得出。

指令在内存中按顺序存放，当顺序执行一段程序时，**根据 PC 从存储器取出当前指令， PC 自动＋ 1，然后执行这条指令**；接着又根据 PC 指示从存储器取出下一条指令， PC 自动＋ 1， 执行……。

###### 跳跃寻址方式

当程序执行转移指令时，程序不再顺序执行，而是跳转到另一个地址去执行，此时，**由该条转移指令的地址码字段可以得到新指令地址，然后将其置入 PC 中。**

##### 数据寻址

指令的地址码字段，通常都不代表操作数的真实地址，把它称作形式地址，记为 A。操作数的真实地址称为有效地址，记作 EA，它是由寻址方式和形式地址共同来确定的。

![image-20200108005008946](/images/computer-organization.assets/image-20200108005008946.png)

###### 立即寻址

在指令中的地址码处直接给出操作数，也就是指令中的地址码字段即为立即数（操作数）。无需在访问储存器。

![image-20200108005929025](/images/computer-organization.assets/image-20200108005929025.png)

###### 直接寻址

指令中的地址码字段直接作为操作数在存储器单元的地址，即为有效抵制 EA = A，按该有效地址访问一次主存便得操作数。

![image-20200108005936167](/images/computer-organization.assets/image-20200108005936167.png)

###### 间接寻址

指令的地址码字段给出存放操作数地址的主存单元地址。根据指令中地址码字段的地址 A 访问存储器，得到操作数在主存中的有效地址 EA， 即 EA = (A)，使用有效地址在此访问主存，得到操作数。

![image-20200108005943492](/images/computer-organization.assets/image-20200108005943492.png)

###### 寄存器寻址方式

指令中的地址码给出寄存器号，操作码在该编号的寄存器中，即 EA = Ri。

![image-20200108010011581](/images/computer-organization.assets/image-20200108010011581.png)

###### 寄存器间接寻址方式

指令中的地址码给出寄存器号，该寄存器中存放的是操作数在主存中的有效地址，即 EA = (Ri)。

![image-20200108010413344](/images/computer-organization.assets/image-20200108010413344.png)

###### 变址寻址

操作数位于存储器中，操作数所在的存储器地址 EA 由变址寄存器 RI 和指令的地址字段 A 指出：
@DATA＝ (EA) \\
EA＝(RI)＋A@

![image-20200108011939566](/images/computer-organization.assets/image-20200108011939566.png)

###### 基址寻址

操作数位于存储器中，操作数所在的存储器地址 EA 由基址寄存器 Rb 和指令的地址字段 A 指出：

\@@@
DATA ＝ (EA)\\
EA ＝ (Rb) ＋ A
\@@@

![image-20200108013617660](/images/computer-organization.assets/image-20200108013617660.png)

###### 基址变址寻址

![image-20200108013728762](/images/computer-organization.assets/image-20200108013728762.png)

###### 相对寻址

操作数位于存储器中，操作数所在的存储器地址 EA 由程序计数器 PC 和指令的地址字段 A 指出：

- DATA ＝（EA）
- EA ＝（PC ）＋ A
- A 通常称作相对偏移量 DISP。
- 相对寻址主要用于转移指令，执行之后，程序将转移到（PC）＋偏移量为地址的指令去执行。
- 偏移量可正、可负，通常用补码表示，即可相对 PC 值向后或向前转移。

###### 堆栈寻址

操作数位于存储器中，操作数所在的存储器地址 EA 由堆栈指针寄存器 SP 隐含指出，通常用于堆栈指令。
堆栈是由若干个连续主存单元组成的先进后出（first in last out，即 FILO）存储区，第一个放入堆栈的数据存放在栈底，最近放入的数据存放在栈顶。栈底是固定不变的，而栈顶是随着数据的入栈和出栈在时刻变化。栈顶的地址由堆栈指针 SP 指明。
一般计算机中，堆栈从高地址向低地址扩展，即栈底的地址总是大于或等于栈顶的地址，称为上推堆栈；也有少数计算机相反，称为下推堆栈。
堆栈寻址主要用来暂存中断和子程序调用时现场数据及返回地址。

#### 指令系统

##### 要求：

1. 完备性：指指令系统直接提供的指令足够使用，而不必用软件来实现。
2. 有效性：是指利用该指令系统所编写的程序能够高效地运行。程序占据存储空间小、执行速度快。
3. 规整性：
   - 对称性：所有的指令都可使用各种寻址方式；
   - 匀齐性：指令可以支持各种数据类型；
   - 指令格式和数据格式的一致性：指令长度和数据长度有一定的关系，以方便处理和存取。
4. 兼容性：“向上兼容”，即低档机上运行的软件可以在高档机上运行。

##### CIRC

早期 CISC 指令系统的主要特点是：

- 指令系统复杂。具体表现为指令条数多、寻址方式多、指令格式多。指令串行执行，大多数指令需要多个时钟周期完成。
- 采用微程序控制，因为微程序控制器适合于实现 CISC 指令执行过程的控制。
- 有较多的专用寄存器，大部分运算所需的数据均需访问存储器获取。
- 编译程序难以用优化措施生成高效的目标代码程序。

CISC 主要在以下方面来对增强指令的功能：

- 面向目标程序增强指令功能
  具体方法有：
  - 提高运算类指令的功能
  - 提高传送类指令的功能
  - 增强程序控制指令功能
- 面向编译程序目标代码生成优化的改进
- 提供面向操作系统优化的指令

##### RISC

大部分 RISC 机具有以下特点：

1. 指令系统设计时选择一些使用频率较高的简单指令，且选择一些很有用但不复杂的指令。
2. 指令长度固定，指令格式种类少，寻址方式种类少。
3. 只有取数/存数指令访问存储器，其余指令的操作都在寄存器之间进行。
4. 采用流水线技术。超级标量及超级流水线技术，增加了指令执行的并行度，使得一条指令的平均指令执行时间小于一个机器周期。
5. CPU 中通用寄存器数量相当多，可以减少访存次数。
6. 以硬布线控制逻辑为主，不用或少用微码控制。
7. 采用优化的编译程序，力求有效地支持高级语言程序。

##### 同 CISC 比较，RISC 的优点

- 可以充分利用 VLSI 芯片面积
- 可以提高计算机运算速度
  - 指令数、寻址方式和指令格式的种类都较少，且指令的编码很有规律，使指令译码加快。
  - 在简化指令的情况下，硬布线连接比微程序控制的延迟小，可缩短 CPU 的周期。
  - CPU 的通用寄存器多，减少了访存次数，加快了速度
  - 大部分指令能在一个周期内完成，特别适合于流水线工作。
  - 有的 RISC 机采用寄存器窗口重叠技术，程序嵌套时不必将寄存器内容保存到存储器中，加快了速度。
- 设计容易，可降低成本，提高可靠性。
- 能有效支持高级语言程序
  - RISC 靠编译程序的优化来支持高级语言程序。
  - 指令少，寻址方式少，反而使编译程序容易选择更有效的指令和寻址方式。
  - 通用寄存器多，可尽量安排快速的寄存器操作，使编译程序的代码优化效率较高。
  - 有的 RISC 机采用寄存器窗口重叠技术，使过程间的参数传送快，且不必保存与恢复现场，因而能直接支持调用子程序和过程的高级语言程序。
  - 在编译时尽量做好程序优化工作，而减少程序执行时间

## 第七章 控制器

### 简答题 & 名词解释

### 控制器

#### 功能

从存储器中取指令、对指令译码、产生控制信号并控制计算机系统各部件有序地执行，从而实现这条指令的功能。

#### 组成

##### 程序计数器（PC）

- 当指令顺序执行时，由 PC+1 产生下一条指令的地址
- 当遇到转移指令时，转移地址 PC 作为下一条指令的地址。

##### 指令寄存器（IR）

##### 指令译码器

##### 操作控制信号形成部件

- 采用硬布线设计的操作控制信号形成部件
- 采用微程序设计的操作控制信号形成部件

##### 时序信号产生器

- 时序信号产生器负责提供时钟信号和机器周期信号，以规定每个操作的时间。
- 时序信号产生器包括启停线路，负责控制时钟脉冲的送出与封锁，从而实现计算机的启动与停止。

##### 地址寄存器（AR）

##### 数据寄存器（DR）

#### 时序系统

指令周期：一条指令执行的时间（包括取出指令的时间），即指计算机从取出一条指令并完成该指令所需要的时间。一般需要几个机器周期时间 才能执行完一条指令。

机器周期（CPU 周期）：一般是指 CPU 与内存交换一次信息（读或写内存)所需要的时间。一般包含若干个时钟周期。
时钟周期：又称为节拍周期，一个 CPU 周期包含若干个时钟周期，是处理操作的最基本时间单位，即 T 周期，一般是时钟频率的倒数。

#### 控制方式

##### 同步控制方式

又称为固定时序控制方式或无应答控制方式。任何指令的执行或指令中每个微操作的执行都受事先安排好的时序信号的控制，每个时序信号的结束就意味着一个微操作或一条指令已经完成，随即开始执行后续的微操作或自动转向下一条指令的执行。

在同步控制方式中，以微操作序列最长的指令为标准，确定控制微操作运行的时钟周期数（节拍数）。控制器产生统一的、顺序固定的、周而复始的节拍电位（机器周期信号）和节拍脉冲（时钟周期信号。

优点：电路简单，缺点：运行速度慢。

##### 异步控制方式

异步控制方式又称可变时序控制方式或应答控制方式。每条指令需要多少节拍，就产生多少节拍；当指令执行完毕，发出回答信号；控制器收到回答信号时，才开始下条指令的执行。

优点：每条指令都可按其实际需要的时间分配节拍，使得指令的运行效率高；
缺点：控制器的电路比较复杂。

异步控制方式在计算机中得到广泛的应用。例如 CPU 对内存的读写；I/O 设备与内存的数据交换等都采用异步控制方式，以保证高速度的执行。

##### 联合控制方式

把同步控制方式和异步控制方式结合使用的一种方式。大部分指令安排在统一的机器周期内完成，即同步控制；而将较少数特殊指令，或微操作序列过长或过短，或微操作时间难以确定的，采用异步控制来完成。

现代计算机系统大多采用联合控制方式，其一般设计思想是，在功能部件内部采用同步控制方式，而在功能部件之间采用异步控制方式。

优点：能保证一定的运行速度
缺点：控制电路设计相对比较复杂。

### 硬布线控制器

硬布线控制器的基本原理是根据指令的要求、当前的时序及外部和内部的状态情况，按时间的顺序发送一系列微操作控制信号。它由复杂的组合逻辑门电路和一些触发器构成，因此又称为组合逻辑控制器，或常规逻辑控制器。

#### 设计步骤

- 确定指令系统，包括指令系统中每条指令的格式、功能和寻址方式。
- 围绕着指令系统的实现，确定 CPU 的内部结构，包括运算器的功能和组成，控制器的组成及它们的连接方式和数据通路，同时也确定时序系统的构成。
- 分析每条指令的执行过程，按机器周期顺序，写出所必需发送的微操作控制信号序列。
- 综合每个微操作控制信号的逻辑函数，化简和优化。
- 用逻辑电路实现。
- 根据 CPU 的结构，写出每条微指令所发送的微操作控制信号序列。
- 结合微程序控制器的结构、微操作控制信号序列和控制存储器容量，设计微指令格式。
- 分配微程序流程图中各微指令的微地址，并编写微指令代码。
- 将所有的微指令代码装入控制存储器的相应单元。

### 微程序控制器

微地址寄存器 μAR、控制存储器（简称控存）、微指令，微地址，微命令，微操作，微周期，微程序

微程序设计思想就是每条机器指令的功能都用一段相应的微程序来实现，在微程序设计中充分运用了软件的程序设计技术，使得微程序流程中也有微程序分支、微程序循环、微子程序等。

**微指令**：一组微命令的集合，用于完成功能相对完整的一个操作。

**微程序**：微指令的集合。

#### 编译法

##### 直接控制法

在微指令的控制字段中，每一位代表一个微命令（控制信号），在设计微指令时，如果要发出某个微命令则将控制字段中对应位置有效，这样就可以打开或关闭某个控制门，这就是直接控制法。如果是编码控制则置相应编码值。

缺点：微指令的控制字段太长

##### 字段直接编译法

如果有一组微命令，在任一个微周期（一条微指令所需的执行时间）只有一个微命令起作用，那么这一组微命令是**互斥的**；通常将在同一个微周期中不能同时出现的微命令称为**相斥性微命令**，而将在同一个微周期中可以同时出现的微命令称为**相容性微命令**。

###### 分段原则

- 相斥性微命令分在同一字段内，相容性微命令分在不同字段内。
- 一般将同类操作中互斥的微命令划分在一个字段内，这样使微指令结构清晰，易于编制微程序和易于扩充功能。
- 每个小字段的信息位不能太长，一般不超过 6 位，否则将增加译码线路的复杂性和译码时间。

##### 字段间接编译法

指某字段的编码含意，除了其本身的编码外，还需要由另一字段来加以解释的编码方法。

字段间接编译法是在字段直接编译法的基础上，进一步缩短微指令字长的一种编译法。

## 第八章 输入输出系统

### 需要接口的理由

外部设备工作的异步性、CPU 与外设速度上的差异、CPU 与外设信号线及数据格式不同。

设置了接口，有利于提高 CPU 的工作效率，也便于外设自身的多样化发展。

### 接口功能

- 实现数据缓冲
- 执行 CPU 命令

- 返回外设的状态

- 设备选择

- 实现数据格式的转换

- 实现信号的转换

- 中断管理功能

### 接口的组成

- 基本电路：主要包括寄存器及其控制逻辑
- 端口地址译码电路：对地址总线上的外设地址进行译码，用以决定是否选中设备自身。
- 供选电路：由于接口的功能和结构有很大的区别，因此各接口电路中可能选择使用中断控制逻辑、定时器、计数器、移位器等器件。

### 外设与主机之间交换信息的方式

#### 程序查询方式

工作原理：CPU 查询外设已准备好后，才传送数据。

特点：CPU 与外设间通过程序同步，CPU 被外设独占，CPU 效率低下。

要求：不需要增加额外的硬件电路。

应用： 适同在 CPU 不太忙且传送速度要求不高时。

![image-20200108022501424](/images/computer-organization.assets/image-20200108022501424.png)

#### 程序中断方式

工作原理：在外设准备数据时， CPU 执行与传送数据无关的工作，外设在准备好数据后，主动向 CPU 发送一个中断请求，当 CPU 执行完当前指令后，停止当前程序的执行，自动转向中断服务程序，在中断服务程序中，完成一个数据的传送，之后中断返回至原来的断点处，继续执行。

特点：在外设准备数据时，CPU 与外设并行工作，CPU 效率有所提高，并且 CPU 可以同时被多个外设占用。

要求：接口中需要中断控制逻辑支持。

应用：适用于中低速设备。

#### 直接存储器访问（DMA）方式

工作原理：将 I/O 过程中，与内存交换数据的操作交由 DMA 控制器来控制，简化了 CPU 对输入输出的控制，进一步提高了 CPU 的效率。

特点：数据的传送不经过 CPU（由 DMAC 控制），而 I/O 设备管理由 CPU 控制，简化了 CPU 对 I/O 的控制。硬件开销大，结构复杂，但 CPU 的效率高。

要求：需要 DMA 控制器及相关逻辑支持。

应用：适用与高速度大量数据传送时。

#### 通道与输入输出机方式

###### 通道

是一个具有特殊功能的处理器，它可以实现对外围设备的统一管理和外围设备与内存之间的数据传送。

特点：能独立地执行用通道指令编写的输入输出控制程序，产生相应的控制信号送给由它管辖的设备控制器，继而完成复杂的输入输出过程。

要求：需要具有特殊功能的处理器，某些应用中称为输入输出处理器（IOP）。

应用：适用与高速度大量数据传送时。

###### 输入输出处理机（IOP）

通常称作外围处理机（PPU），它是通道方式的进一步发展。这种 PPU 基本上独立于主机工作，它的结构更接近一般处理机，甚至就是微小型计算机。

特点： I/O 处理机接管了 CPU 的各种 I/O 操作及 I/O 控制功能，CPU 能与 IOP 并行工作。

要求：需要 IOP 支持。

应用：高速 I/O 归 IOP 管理，低速 I/O 设备归 CPU 管理。

### 中断系统

#### 中断

在 CPU 执行程序的过程中，由于某种事件发生，CPU 暂时终止正在执行的程序而转向对所发生的事件进行处理，当对事件的处理结束后由能回到发生终止时的地方，接这种之前的状态继续执行原来的程序，这一过程称为**中断**。

#### 中断源

由于某种原因引起 CPU 中断的事件或设备。中断源一般可以分为硬中断和软中断两类。

##### 硬中断

由外部设备和其他 CPU 外部事件引起的中断，因此又叫外中断。

常见的外部中断有输入输出请求、实时时钟、计时器、电源故障、设备故障、校验线路等等。外中断一般通过 CPU 的中断请求引脚引入。

例如，在 80X86 系列 CPU 上，设有 INTR、NMI 两个中断请求引脚。

##### 软中断

指 CPU 内部的指令或程序执行中的突发事件所引起的中断，又叫内中断。

常见的软中断主要包括指令中断（例如中断指令 INT n）和程序异常（例如除数为零，运算溢出、指令的单步运行、程序运行至断点处等等）。

#### 中断类型号 & 中断向量

在很多中断系统中，对所有的中断源编码，为其分配一个惟一的代号，称为**中断类型号**。例如，80X86 有 256 种中断类型，因此中断类型号为 8 位二进制（0-255）。中断类型号用于寻找中断服务程序的入口地址（**中断向量**），以实现程序转移。

#### 中断过程

##### 中断请求

###### 对于外中断

外设或其他中断源通过 CPU 的中断请求引脚向 CPU 发中断请求信号，CPU 在每条指令执行完后，监测是否有中断请求，有效则转入中断响应阶段。

###### 对于内中断

则无需中断请求，直接可以根据中断类型号转入相应的中断服务程序。

###### 需解决的主要问题是：

- 中断屏蔽：对那些 CPU 目前不准备响应的中断源，CPU 如何禁止它们产生中断请求？
- 中断请求信号的传递：当系统中有多个中断源时，各中断源如何向 CPU 提出中断请求？
- CPU 对中断请求信号的监测：CPU 如何监测到有中断请求？

##### 中断响应

CPU 首先通过硬件保存**程序断点（PC）及标志寄存器**，以便中断返回，由于该过程对软件设计者是透明的，因此又称为 CPU 执行了中断隐指令。然后进入中断响应周期，或者通过向量方式或者通过软件查询方式得到中断服务程序入口，并置入 PC。

###### 需解决的主要问题是：

中断优先级的判别：如果同一时刻有多个中断源向 CPU 申请中断，CPU 首先响应那个中断？
中断源的识别：CPU 如何知道当前响应的是哪个中断源？即：转入哪个中断源的中断服务程序入口？

##### 中断服务

中断服务程序中，首先保护现场，将有关寄存器的内容压栈，然后进行 I/O 操作，实现数据传送。最后，恢复现场，并执行中断返回指令。

###### 需解决的主要问题是：

中断嵌套：如果 CPU 在执行某个中断服务程序的过程中，又发生新的中断请求，那么 CPU 如何处理？

##### 中断返回

中断返回指令的功能是：将中断隐指令保存的程序断点和标志读出并送入 PC 和标志寄存器，从而回到 CPU**原来的程序断点处**继续执行。

![image-20200108023144833](/images/computer-organization.assets/image-20200108023144833.png)

#### 中断的作用

- 实现 CPU 和多台 I/O 设备并行工作
- 具有处理应急事件的能力
- 进行实时处理
- 实现人机通信
- 实现多道程序运行和分时操作
- 实现应用程序和操作系统（管态程序）的联系
- 实现多机系统中各处理机间的联系

#### 中断优先级

指有多个中断同时发生时，CPU 对中断源响应的次序。

中断请求的排队判优，常用的方法有两种：**软件查询**和**硬件排队电路**

##### 软件查询法

用程序来判断优先级，这是最简单的中断判优方法。软件查询法用于一根公共请求线的情况

优点：可以灵活地修改中断源的优先级别，硬件电路实现简单；

缺点：查询、判优完全靠程序实现，需要占用 CPU 时间，同时中断响应较慢，优先级较低的设备被响应的等待时间也较长。

##### 硬件排队电路

优先级别高的中断请求将自动封锁优先级别低的中断请求的处理。硬件排队电路一旦设计连接好之后，将无法改变其优先级别。

###### 串行排队链与向量中断

适用于向量中断方式，中断响应信号逐级传送，先到达的设备，其优先级高于中断响应信号后到达的设备，即电路中距离 CPU 最近的中断源优先级最高，这里距离远近是指电气上的信号传递顺序。这种方法实现时电路较简单，但优先级固定，取决于固定的硬件连接，不够灵活，不易于改变或调整优先级。

###### 独立请求优先级排队电路

###### 二维结构优先排队判优电路

#### 中断响应

#### 条件

- CPU 的中断使能触发器开放（IE=1，允许中断）；
- 在规定的时间内，CPU 的中断请求引脚有效；
- 该中断未被屏蔽；
- 本条指令执行完；

##### 过程

- 关中断
  当 CPU 响应中断后，立即自动关中断（把内部的中断使能触发器 IE 清零），禁止接收新的中断，以保证接下来中断隐指令操作不被打断。

- 保存断点
  断点信息包括两部分：PC 和程序状态字 PSW。断点通常保存在堆栈中，有些计算机中将断点保存在特殊的中断返回寄存器中。

- 识别中断源，转入服务程序入口地址
  中断源识别的方法有两种：**向量中断**和**软件查询**

  - **向量中断**

    中断服务程序入口地址被称为中断向量。通常将各中断源的中断向量存放在内存一片连续的单元中，形成一张中断向量表，表的内容是相应的中断服务程序入口地址，存放中断向量的单元地址称为中断向量地址，简称为向量地址。

    当 CPU 响应中断时，由硬件（外设接口或者中断控制器）自动产生一个指定的地址（向量地址）或者代码（中断类型号），它们与该中断源的中断向量有一一对应关系。由向量地址或中断类型号指出每个中断源设备的中断向量（中断服务程序入口地址），这种使用向量识别中断源的中断系统称为向量中断。

  - **软件查询**
    由 CPU 执行一个公共的中断处理程序，逐个询问外设接口有否发出中断请求（测试中断请求触发器），若有中断请求，则转入其中断服务程序的入口开始执行。

#### 中断服务与返回

断点也是线程

#### 中断屏蔽技术

## 第九章 总线

### 总线 （名词解释）

指通过分时共享的方式，将信息以一个或多个源部件传送到一个或多个目的部件的一组传输线。是计算机中传输数据的**公共通道**。

### 总线总裁（名词解释）

总线上可以挂很多设备，但任一时刻都只能由一个设备控制和使用总线，此设备称为主设备。

当多个设备同时提出使用总线的请求时，必须由总线控制器按事先规定的原则进行仲裁，确定使用总线的先后次序，从而决定由哪一个设备控制总线，称为**总线仲裁**。

#### 仲裁方式

##### 集中式仲裁

###### 链式查询方式

优点：只用很少几根线就能实现按一定优先级的总线仲裁，并且链式结构很容易扩充设备。

缺点：对查询链的电路故障很敏感，如果第 i 个设备接口中有关链的电路出现故障，则该设备后的设备都不能工作。

###### 计数器定时查询方式

优点：优先级设置较为灵活。

缺点：需要增加额外的计数线。

###### 独立请求方式

优点：响应速度快，即确定优先响应的设备所花费的时间少，不需要一个设备接一个设备地查询；而且，对优先级的控制非常灵活，总线控制器可以根据一定的仲裁算法给各请求线以固定的优先级；也可以通过编程设置动态优先级；另外还可以用屏蔽（禁止）某个请求线的办法，不响应无效设备的请求。由于独立请求方式的这些优点，因此现代总线标准普遍采用独立请求方式。

缺点：信号线多。

#### 分布式仲裁

###### 自举分布式仲裁

缺点：需要较多的连线，每个设备不仅要有发出总线请求的线，还要有接收其他设备的总线请求线。

###### 冲突检测分布式仲裁方式

主要用于网络通信总线。

###### 并行竞争仲裁方式

每个主设备都有自己的仲裁号和控制器，当某个设备有总线请求时，把它的仲裁号发送到共享的仲裁线上，每个设备的控制器将仲裁线上接收到的号与自己的仲裁号进行比较，如果比自己的仲裁号大，则在仲裁线上撤销自己的仲裁号。最后，竞争获胜者的仲裁号被保留在仲裁线上。显然，这种方案中仲裁号越大，优先级越高。

并行竞争分布式仲裁比自举分布式仲裁所需的的连接线要少，因为，并行竞争分布式仲裁中，对于 n 根仲裁线可以表示个优先级。例如，在并行竞争分布式仲裁中，具有 8 根仲裁线共可以表示 256 个优先级，仲裁号为 255 的设备优先级最高，仲裁号为 0 的设备优先级最低。而在自举分布式仲裁中，请求线是 8 根，只能表示 8 个优先级，也即只有对 8 个设备进行仲裁。

### 填空题

#### 电气特性

电气特性指总线上每一根传输线的信号传递方向和有效电平范围。

#### 机械特性

机械特性指总线在机械连接方式上的一些特性。

#### 功能特性

功能特性指总线中每一根传输线的功能。

#### 时间特性

时间特性指总线的每一根传输线在什么时间内有效，以及每一根线产生的信号之间时序关系。时间特性一般可以用信号的时序图来表示。
只有严格按照总线特性设计的部件或外设接口，才能保证系统的可靠传输和运行。

### 总线的性能指标

#### 总线宽度

即数据总线宽度，指一次总线操作中通过总线传送的数据位数，一般有 8、16、32 和 64 位。

#### 总线频率

总线的工作频率，单位是 MHZ。工作频率越高，总线工作速度越快，总线带宽越宽。

#### **总线带宽**（计算）

指单位时间内总线上可传送的数据量，用每秒多少兆字节（MB/S）表示。

总线带宽 = 总线宽度/8 × 总线工作频率 MB/s

#### 总线周期

指一次总线操作所用的时间。
